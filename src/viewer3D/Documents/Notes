To Do List :
- Implement a 3D shape class that keeps track of it's edges and surfaces
- Implement a 2D shape class that is generated by projecting a 3D shape, while preserving edges

- Surfaces
- Collisions

Shape3D
- vertices
- edges
- surfaces 





I want to have a 3D shape projected into 2D, I can project the vertices relatively easily,
but after the projection, the vertices need to remember which other vertices they're attached to
and surfaces need to know what they're in front of as well 


Need a shape to observe that exists in a 3D space(cuboid), and then implement the camera projection, then camera movement


Initialize Camera (**IMPLEMENTED**)
    - get observer point
    - get focal length
    - get normal vector
    - create projection plane
    - get fov (x and y)
    - use fov to determine vertices of projection rectangle
    - determine the number of pixels wide and high
    - split projection rectangle into array of points, one for each pixel

Project onto Projection Plane
    - Create a Camera somewhere in space
    - Create a geometric object somewhere in view
    - Begin observing

Observation
    - Camera is given a polygon and its vertices
    - A line is drawn from the observer to each vertice, and the x,y,z angle calculated
    - the projection points lying between the x,y,z angles of each vertice are selected
    - the intersection of each observer/projection point line with the polygon is found
    - the polygon returns the color at that intersection
    - The color is stored with it's corresponding projection point
    - When the full observation is complete the set of colors are drawn to the screen
    
Camera Movement
    - Position
        - Position can be controlled through the plane orthogonal to the projection plane, using the w,a,s,d keys, 
        - Velocity setting controls distance/time
    - Rotation
        - Rotation can be controlled through the mouse position
        - Sensitivity setting controls radians/time

What code is required?
    - Classes
        - Camera
        - Polygon
        - 



Camera coordinate space
    - Camera has x,y,z angles
    - x,y,z rotation matrices can be applied to projection points
    - by projecting a polygon onto the projection plane, the intersecting locations can be found
    - create a vector from the observer point to a vertex
    - find the intersection of that vector from the origin to the plane
    - map it to the simplified 2D plane
    - use 2D geometry to determine which points lie within the bounds of the resulting triangle





I have a 3D plane described by a normal vector, and a position vector (point on the plane)
I have some vertices of a polygon projected onto that plane


My overall requirement is that I am able to see the polygon
To do that I need a camera
The camera needs a way to see the polygon
I've chosen to cast rays out of the camera

Since I already have a projection plane, and I know how to project a polygon onto it, another option is to 
map the vertices to 2D (same so far) but then get the bounds of the 2D triangle, and fill it with the transformed
polygon mesh


- Project the vertices of a simplex in R3 onto a 3D plane. *done*

-------------------------- (this is the tricky part)
- Map the projected vertices onto a 2D plane
    - One possibility is to find the rotation of the plane that causes it to run perpendicular to the z-axis.
      All I need to do from there is drop the z-coordinate and I have my 2D plane. To do that, I need to figure
      out how to rotate a plane so that it's normal is co-linear with the z-unit vector

- Need an algorithm to generate the pixel points that lie within the triangle. 
    - A simpler less efficient method would be to stay with my current model, generating points in R3 on the plane,
      then rotating all of them with the vertices, and checking each point to see if it lies within the triangle

- From the ratio of the pixel points domain and range to the plane rectangles domain and range, generate points
  at the same relative positions on the 3D plane.
--------------------------

- Create vectors that intersect the 3D plane points and find their intersection vectors with the polygon.
- Pass the intersection vectors to the polygons, and receive pixel information for that vector.



want the translation vector that lies on the camera plane which is perpendicular

The rotation algorithm is correctly rotating the projection normal and observer normal

Need to implement
    - world rotation 
    - field of view
    - backface detection

*Triangle recursive point searcher*
    Before you even start, you can narrow the space using the bounding rectangle of the triangle
    You could initialize a 2D boolean flag array, then calculate the points on the edge, between two vertices, flip the
    value of all points on the outside of the edge, then repeat with the next two edges, then 
    Start at one of the vertices,
    Perhaps there is a way to crawl the edges, and then walk through the ranges without needing to run any check alg
    If you knew that you that the other vertices were to the right of the starting vertex, 
    you could move diagonally, until you hit an impasse, then you could go right and up. If you hit another impasse, you're
    at the next vertex


Full pixel array costs 5.184 mb

([n] number of polygons)* ([t] point in polygon algorithm time) * ([p] number of pixels)

For a resolution of 1440*900

Let T = the total time taken for the point in polygon algorithm for all polygons
T = 5.184*10^6*t*n 

For a check time of 1 ms, T in seconds is
T = 5.184*10^3*n

Even for a check time of 1 ns that would be 5.184 s per pixel


Instead, I can generate the points inside the polygon, get the intersections, and place their content in the data array

([n] number of polygons)*([p] number of pixels in the polygon)*([g] pixel point generation time)*([i] intersection calculation time)
T = n*p*g*i (where p is a function of n)

Generate Pixel Points in Polygons

Get rectangle bound of triangle, store maxX, minX, maxY, minY
Get a single point in the triangle and walk recursively through the pixel points
