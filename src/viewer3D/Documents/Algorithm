CURRENT GRAPHICS PIPELINE

World space
Get set of polygons, give to camera
Camera maps all polygons to projection plane
projection plane is rotated to align perpendicular to z-axis
rotate projection plane is adjusted to screen space (translation)
camera passes polygons to controller which passes them to the drawer
the drawer converts the polygons to 2D polygons, which are then filled


GRAPHICS PIPELINE
    World space
    Set of polygons
    Project polygons onto camera plane
    Map projection plane to screen plane
    Generate pixels
    
POLYGON SORTING ALGORITHM
    
PIXEL ALGORITHM
    Create a grid of pixel points on the screen space
    Find the set of polygons that are intersected by a line going through the observer and a pixel point on the projection plane
    Tell each polygon to give the color present at the intersection point
    Store the distance of the intersection point from the observer, as well as the color
    Find the polygon point that is the minimum distance from the observer, and set the pixel array to that color
    
    Pixel Point Grid algorithm(implemented)
    Pixel is in Polygon algorithm
        (good)      https://www.geeksforgeeks.org/check-whether-a-given-point-lies-inside-a-triangle-or-not/
        (better)    https://math.stackexchange.com/questions/51326/determining-if-an-arbitrary-point-lies-inside-a-triangle-defined-by-three-points
    OR Generate Pixel Points in Polygons algorithm
    Intersection Algorithm (implemented)
    

Full pixel array costs 5.184 mb

([n] number of polygons)* ([t] point in polygon algorithm time) * ([p] number of pixels)

For a resolution of 1440*900

Let T = the total time taken for the point in polygon algorithm for all polygons
T = 5.184*10^6*t*n 

For a check time of 1 ms, T in seconds is
T = 5.184*10^3*n

Even for a check time of 1 ns that would be 5.184 s per pixel


Instead, I can generate the points inside the polygon, get the intersections, and place their content in the data array

([n] number of polygons)*([p] number of pixels in the polygon)*([g] pixel point generation time)*([i] intersection calculation time)
T = n*p*g*i (where p is a function of n)

Generate Pixel Points in Polygons

Get rectangle bound of triangle, store maxX, minX, maxY, minY
Get a single point in the triangle and walk recursively through the pixel points

*Triangle recursive point searcher*
    Before you even start, you can narrow the space using the bounding rectangle of the triangle
    You could initialize a 2D boolean flag array, then calculate the points on the edge, between two vertices, flip the
    value of all points on the outside of the edge, then repeat with the next two edges, then 
    Start at one of the vertices,
    Perhaps there is a way to crawl the edges, and then walk through the ranges without needing to run any check alg
    If you knew that you that the other vertices were to the right of the starting vertex, 
    you could move diagonally, until you hit an impasse, then you could go right and up. If you hit another impasse, you're
    at the next vertex

    each


TRIANGLE POINT FINDING TRIPLE EDGE BASED ALGORITHM
    Select two vertices
    Convert coordinates of vertices to match resolution domain and range
    Round the coordinates to the nearest integer to find the closest grid point
    Find the line points at every integer y between the vertex grid points
    Round the x coordinates of the line points
    Repeat for each edge

    Use relative position of each line point to get indices of all corresponding points in the screenspace array

    We now have a quantized grid of points representing the edges of the triangle
    The intersection algorithm can be run on the intervals bounded by the edge points, without performing extra triangle checks

Pros 
    Less in-triangle checks
Cons
    More edge point calculations

How do we build it?
    Make a triangle
    Make a grid of points with the width and height of the desired resolution
    Convert vertices to resolution space
    

TRIANGLE POINT FINDING SINGLE EDGE BASED ALGORITHM

Find the highest and lowest vertex
Find if the remaining vertex is on the left or right of the line



FULL GRAPHICS PIPELINE
    √ Generate Polygons
    √ Project Polygons to a projection plane
    √ Generate pixel points on projection plane in a 2D array of vectors, one for every pixel
    √ Map projection plane (and its polygons) to screen space
    Create Raster corresponding to screen pixels
    Access each screen space polygon
        Find any point on screen space polygon
        Recursively walk through points on projected polygon
            √ check if point exists in triangle
            use point coordinates relative to screenspace to get corresponding index of 2D projection plane vector array
            Get intersection of world space polygon through observer and point at found index in vector array
            Retrieve and store, color and observer distance, in the raster
            walk to the next point in screen space
    return the raster to the controller
    pass the raster to the drawer




